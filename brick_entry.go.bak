//
// Copyright (c) 2015 The heketi Authors
//
// This file is licensed to you under your choice of the GNU Lesser
// General Public License, version 3 or any later version (LGPLv3 or
// later), or the GNU General Public License, version 2 (GPLv2), in all
// cases as published by the Free Software Foundation.
//

package main

import (
	"bytes"
	"encoding/gob"
	"sort"
	"time"

	"github.com/boltdb/bolt"
	"github.com/heketi/heketi/pkg/glusterfs/api"
	"github.com/heketi/heketi/pkg/utils"
	"github.com/lpabon/godbc"
)

type BrickEntry struct {
	Info             api.BrickInfo
	TpSize           uint64
	PoolMetadataSize uint64
	gidRequested     int64
}

func BrickList(tx *bolt.Tx) ([]string, error) {

	list := EntryKeys(tx, BOLTDB_BUCKET_BRICK)
	if list == nil {
		return nil, AccessList
	}
	return list, nil
}

func NewBrickEntry(size, tpsize, poolMetadataSize uint64,
	deviceid, nodeid string, gid int64, volumeid string) *BrickEntry {

	godbc.Require(size > 0)
	godbc.Require(tpsize > 0)
	godbc.Require(deviceid != "")
	godbc.Require(nodeid != "")

	entry := &BrickEntry{}
	entry.gidRequested = gid
	entry.TpSize = tpsize
	entry.PoolMetadataSize = poolMetadataSize
	entry.Info.Id = utils.GenUUID()
	entry.Info.Size = size
	entry.Info.NodeId = nodeid
	entry.Info.DeviceId = deviceid
	entry.Info.VolumeId = volumeid

	godbc.Ensure(entry.Info.Id != "")
	godbc.Ensure(entry.TpSize == tpsize)
	godbc.Ensure(entry.Info.Size == size)
	godbc.Ensure(entry.Info.NodeId == nodeid)
	godbc.Ensure(entry.Info.DeviceId == deviceid)

	return entry
}

func NewBrickEntryFromId(tx *bolt.Tx, id string) (*BrickEntry, error) {
	godbc.Require(tx != nil)

	entry := &BrickEntry{}
	err := EntryLoad(tx, entry, id)
	if err != nil {
		return nil, err
	}

	return entry, nil
}

func (b *BrickEntry) BucketName() string {
	return BOLTDB_BUCKET_BRICK
}

func (b *BrickEntry) SetId(id string) {
	b.Info.Id = id
}

func (b *BrickEntry) Id() string {
	return b.Info.Id
}

func (b *BrickEntry) Save(tx *bolt.Tx) error {
	godbc.Require(tx != nil)
	godbc.Require(len(b.Info.Id) > 0)

	return EntrySave(tx, b, b.Info.Id)
}

func (b *BrickEntry) Delete(tx *bolt.Tx) error {
	return EntryDelete(tx, b, b.Info.Id)
}

func (b *BrickEntry) NewInfoResponse(tx *bolt.Tx) (*api.BrickInfo, error) {
	info := &api.BrickInfo{}
	*info = b.Info

	return info, nil
}

func (b *BrickEntry) Marshal() ([]byte, error) {
	var buffer bytes.Buffer
	enc := gob.NewEncoder(&buffer)
	err := enc.Encode(*b)

	return buffer.Bytes(), err
}

func (b *BrickEntry) Unmarshal(buffer []byte) error {
	dec := gob.NewDecoder(bytes.NewReader(buffer))
	err := dec.Decode(b)
	if err != nil {
		return err
	}

	return nil
}

// Size consumed on device
func (b *BrickEntry) TotalSize() uint64 {
	return b.TpSize + b.PoolMetadataSize
}

func xmain() {
	tmpfile := "heketi.db"

	// Setup BoltDB database
	db, err := bolt.Open(tmpfile, 0600, &bolt.Options{Timeout: 3 * time.Second})
	if err != nil {
		println(err.Error())
	}

	//defer os.Remove(tmpfile)

	// Try to view
	err = db.View(func(tx *bolt.Tx) error {

		brick_entries, err := BrickList(tx)
		if err != nil {
			println(err.Error())
		}

		for _, brick := range brick_entries {
			println(brick)
		}

		return nil
	})

	//delete 5e74f6fe2c2e522e81e041e3d09ea7aa
	db.Update(func(tx *bolt.Tx) error {

		//Access brick
		brick, err := NewBrickEntryFromId(tx, "5e74f6fe2c2e522e81e041e3d09ea7aa")
		if err != nil {
			println(err.Error())
			return err
		}

		// Access device
		device, err := NewDeviceEntryFromId(tx, brick.Info.DeviceId)
		if err != nil {
			println(err.Error())
			return err
		}

		// Deallocate space on device
		device.StorageFree(brick.TotalSize())

		// Delete brick from device
		device.BrickDelete(brick.Info.Id)

		// Save device
		err = device.Save(tx)
		if err != nil {
			println(err.Error())
			return err
		}

		// Delete brick entryfrom db
		err = brick.Delete(tx)
		if err != nil {
			println(err.Error())
			return err
		}

		v := &VolumeEntry{}
		v.Bricks = make(sort.StringSlice, 0)

		gob.Register(&NoneDurability{})
		gob.Register(&VolumeReplicaDurability{})
		gob.Register(&VolumeDisperseDurability{})

		// Delete brick from volume db
		v.BrickDelete(brick.Info.Id)
		if err != nil {
			println(err.Error())
			return err
		}

		//d.Bricks = utils.SortedStringsDelete(d.Bricks, id)

		// NewBrickEntry, err := NewBrickEntryFromId(tx, "5e74f6fe2c2e522e81e041e3d09ea7aa")
		// if err != nil {
		// 	println(err.Error())
		// }
		//var brickname = "2dd18ca3c56d86a608edc852e887c4c6"
		//NewBrickEntry := &BrickEntry{}

		// err = EntryDelete(tx, NewBrickEntry, brickname)
		// if err != nil {
		// 	println(err.Error())
		// }
		// println("Delete brick id [%s]:", brickname)

		return nil
	})

	// Verify to view
	err = db.View(func(tx *bolt.Tx) error {

		return nil
	})

	// // Create a bucket
	// entry := &testDbEntry{}
	// err = db.Update(func(tx *bolt.Tx) error {

	// 	// Create Cluster Bucket
	// 	_, err := tx.CreateBucketIfNotExists([]byte(entry.BucketName()))
	//     if err != nil {
	//             println(err.Error())
	//     }

	// 	// Register a value
	// 	_, err = EntryRegister(tx, entry, "mykey", []byte("myvalue"))
	//     if err != nil {
	//             println(err.Error())
	//     }

	// 	return nil
	// })

	// // Try to write key again
	// err = db.Update(func(tx *bolt.Tx) error {

	// 	// Save again, it should not work
	// 	val, err := EntryRegister(tx, entry, "mykey", []byte("myvalue"))
	//     if err != nil {
	//             println(err.Error())
	//     }

	//             println(string(val))

	//             newDeviceEntry, err := NewDeviceEntryFromId(tx, d.Id())
	//             if err != nil {
	//                     return err
	//             }

	// 	// Remove key
	// 	err = EntryDelete(tx, entry, "mykey")

	// 	// Register again
	// 	_, err = EntryRegister(tx, entry, "mykey", []byte("myvalue"))

	// 	return nil
	// })

}
